# Stripe-Style Changelog Format

This document explains the new comprehensive changelog format inspired by Stripe's changelog design and how each field is generated by AI from your Git commits.

## Overview

The new format transforms your technical Git commits into professional, user-friendly changelog entries that work for both developers and business users. Instead of just listing commits, it creates a narrative around what changed and why it matters.

## Format Structure

Each changelog entry now includes these sections:

### 1. **Title** 
A concise, descriptive headline that summarizes the main theme of the changes.

**How it's generated:**
- AI analyzes all commit messages and changes
- Identifies the primary theme or most significant change
- Creates a descriptive title (e.g., "Adds balance types to the Balance Transactions API")
- Follows Stripe's pattern of action-oriented titles

**Examples:**
- `"Introduces real-time notifications"`
- `"Enhances dashboard performance"`
- `"Adds advanced filtering capabilities"`

### 2. **What's new**
A 1-2 sentence summary of what was added/changed and its primary benefit.

**How it's generated:**
- AI distills the essence of all changes into a clear, non-technical summary
- Focuses on user-facing benefits rather than implementation details
- Written for a general audience who wants to quickly understand the update

**Examples:**
- `"This release introduces real-time notifications that keep users informed about important events as they happen."`
- `"Enhanced dashboard performance provides faster loading times and smoother interactions."`

### 3. **Impact**
2-3 sentences explaining how this affects users, what they can now do, and why it matters.

**How it's generated:**
- AI analyzes the functional changes and translates them into user benefits
- Explains the "why it matters" aspect
- Describes new capabilities or improvements to existing workflows
- Focuses on practical implications for end users

**Examples:**
- `"Users can now receive instant alerts about critical system events, reducing response times and improving workflow efficiency. The notifications are customizable, allowing users to filter and prioritize the information most relevant to their needs."`

### 4. **Changes**
Technical details organized by category (Features, Bug Fixes, Improvements, Breaking Changes).

**How it's generated:**
- AI categorizes each commit based on its type and content
- Groups related changes together
- Maintains technical accuracy while improving readability
- Uses consistent formatting and action-oriented language

**Categories:**
- **‚ú® Features**: New functionality or capabilities
- **üêõ Bug Fixes**: Corrections to existing functionality  
- **üöÄ Improvements**: Enhancements to existing features
- **‚ö†Ô∏è Breaking Changes**: Changes that may require user action

### 5. **Upgrade** (Optional)
Step-by-step instructions if users need to take action.

**How it's generated:**
- AI identifies when changes require user intervention
- Creates clear, actionable steps for upgrading
- Only included when necessary (omitted for non-breaking changes)
- Written in imperative, easy-to-follow language

**Examples:**
- `"1. Update your SDK to v2.1.0 or later\n2. Replace deprecated endpoints with new ones\n3. Update your authentication headers"`
- `"No user action required for this release."`

### 6. **Related** (Optional)
Mentions related changes or dependencies.

**How it's generated:**
- AI identifies connections between changes and other features
- References related documentation or previous updates
- Only included when there are genuine relationships
- Helps users understand the broader context

**Examples:**
- `"This update builds on the API improvements released last month."`
- `"See the Authentication Guide for updated security recommendations."`

## AI Prompt Engineering

The AI uses sophisticated prompts to generate these fields:

### Analysis Process
1. **Commit Classification**: Categorizes each commit by type and impact
2. **Content Analysis**: Examines actual code changes, not just commit messages
3. **User Impact Assessment**: Determines how changes affect end users
4. **Narrative Construction**: Builds a coherent story around the changes
5. **Audience Adaptation**: Writes for both technical and non-technical readers

### Quality Assurance
- **Consistency**: Uses established patterns and terminology
- **Accuracy**: Maintains technical correctness while improving clarity
- **Completeness**: Ensures all significant changes are captured
- **Professional Tone**: Matches Stripe's professional, clear communication style

## Backward Compatibility

The system supports both formats:
- **New format**: Includes title, whatsNew, impact, upgrade, and related fields
- **Legacy format**: Falls back to the original structure if AI parsing fails
- **Graceful degradation**: Website displays appropriately for both formats

## Implementation Details

### CLI Generation
```bash
# Generates Stripe-style format by default
npx changelog-ai generate --commits 5
```

### File Structure
```markdown
---
title: "Descriptive changelog title"
whatsNew: "Brief summary of changes"
impact: "How this affects users"
upgrade: "Instructions if needed"
related: "Related changes if any"
---

# Descriptive changelog title

## What's new
Brief summary...

## Impact
User impact explanation...

## Changes
### ‚ú® Features
- Feature details...

## Upgrade (if needed)
Step-by-step instructions...

## Related changes (if any)
Related information...
```

### Web Display
The website automatically detects the format and displays:
- Rich, Stripe-inspired layout for new format
- Legacy layout for older changelogs
- Responsive design with proper typography hierarchy

## Benefits

### For End Users
- **Clarity**: Understand what changed without technical jargon
- **Context**: Know why changes matter and how they're affected
- **Actionability**: Clear instructions when updates are needed

### For Developers
- **Efficiency**: Automated generation from Git commits
- **Consistency**: Standardized format across all releases
- **Professionalism**: Publication-ready changelog entries

### For Product Teams
- **Communication**: Bridge technical changes with business impact
- **Documentation**: Comprehensive record of product evolution
- **Marketing**: User-friendly content for release announcements

## Best Practices

### Commit Messages
To get the best AI-generated changelogs:
- Use conventional commit formats (`feat:`, `fix:`, `docs:`)
- Write descriptive commit messages explaining the "what" and "why"
- Include context about user impact when relevant

### Review Process
- Always review AI-generated content before publishing
- Edit titles and summaries for brand voice consistency
- Add specific upgrade instructions if needed
- Verify technical accuracy of the Changes section

---

This format transforms your technical Git history into professional, user-focused communication that works for developers, product managers, and end users alike. 